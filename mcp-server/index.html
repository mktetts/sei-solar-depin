<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEI Solar Charging Station - MCP Chatbot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chat-container {
            width: 90%;
            max-width: 800px;
            height: 90vh;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .api-key-section {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .api-key-section input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .api-key-section button {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .api-key-section button:hover {
            background: #218838;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 15px;
            max-width: 70%;
            animation: fadeIn 0.3s ease-in;
        }

        .message.user {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .message.assistant {
            background: white;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .message.system {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            text-align: center;
            font-size: 0.9rem;
        }

        .message .content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .message .timestamp {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }

        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input textarea {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 20px;
            resize: none;
            font-family: inherit;
            font-size: 1rem;
            min-height: 20px;
            max-height: 120px;
            outline: none;
        }

        .chat-input textarea:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        .chat-input button {
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.1s ease;
        }

        .chat-input button:hover {
            transform: translateY(-1px);
        }

        .chat-input button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 10px 20px;
            background: #e9ecef;
            border-top: 1px solid #dee2e6;
            font-size: 0.9rem;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status .connection {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status .connection::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #dc3545;
        }

        .status .connection.connected::before {
            background: #28a745;
        }

        .typing {
            display: none;
            font-style: italic;
            color: #6c757d;
            padding: 10px 20px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tool-call {
            background: #f1f3f4;
            border-left: 3px solid #667eea;
            margin: 10px 0;
            padding: 10px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .chat-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }

            .message {
                max-width: 85%;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="header">
            <h1>ðŸ”‹ SEI Solar Charging Station</h1>
            <p>MCP-Powered AI Assistant for EV Charging</p>
        </div>

        <div class="api-key-section">
            <input type="password" id="apiKey" placeholder="Enter your OpenAI API Key">
            <button id="saveApiKey">Save Key</button>
        </div>

        <div class="chat-messages" id="chatMessages">
            <div class="message system">
                <div class="content">Welcome to the SEI Solar Charging Station AI Assistant! I'm here to help you with EV charging operations on the SEI blockchain. Please enter your OpenAI API key to get started.</div>
                <div class="timestamp" id="welcomeTime"></div>
            </div>
        </div>

        <div class="typing" id="typing">AI is thinking...</div>

        <div class="chat-input">
            <textarea id="messageInput" placeholder="Ask me about charging stations, bookings, or wallet operations..." rows="1"></textarea>
            <button id="sendButton">Send</button>
        </div>

        <div class="status">
            <div class="connection" id="connectionStatus">
                Connecting to MCP Server...
            </div>
            <div id="messageCount">0 messages</div>
        </div>
    </div>

    <script>
        class SEIChargingChatbot {
            constructor() {
                this.apiKey = localStorage.getItem('openai_api_key') || '';
                this.conversationHistory = [];
                this.eventSource = null;
                this.isConnected = false;
                this.messageCount = 0;

                this.initializeElements();
                this.setupEventListeners();
                this.loadApiKey();
                this.connectToMCPServer();
                this.updateWelcomeTime();
            }

            initializeElements() {
                this.apiKeyInput = document.getElementById('apiKey');
                this.saveApiKeyButton = document.getElementById('saveApiKey');
                this.chatMessages = document.getElementById('chatMessages');
                this.messageInput = document.getElementById('messageInput');
                this.sendButton = document.getElementById('sendButton');
                this.typingIndicator = document.getElementById('typing');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.messageCountDisplay = document.getElementById('messageCount');
            }

            setupEventListeners() {
                this.saveApiKeyButton.addEventListener('click', () => this.saveApiKey());
                this.sendButton.addEventListener('click', () => this.sendMessage());
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                this.messageInput.addEventListener('input', () => this.adjustTextareaHeight());
            }

            loadApiKey() {
                if (this.apiKey) {
                    this.apiKeyInput.value = this.apiKey;
                    this.addSystemMessage('API key loaded from storage. You can now chat with the AI assistant.');
                }
            }

            saveApiKey() {
                const key = this.apiKeyInput.value.trim();
                if (key) {
                    this.apiKey = key;
                    localStorage.setItem('openai_api_key', key);
                    this.addSystemMessage('API key saved securely. You can now interact with the AI assistant.');
                    this.apiKeyInput.type = 'password';
                } else {
                    this.addSystemMessage('Please enter a valid API key.', 'error');
                }
            }

            connectToMCPServer() {
                try {
                    this.eventSource = new EventSource('http://127.0.0.1:8080/sse');

                    this.eventSource.onopen = () => {
                        this.isConnected = true;
                        this.updateConnectionStatus(true);
                        this.addSystemMessage('Connected to MCP server successfully.');
                    };

                    this.eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMCPServerMessage(data);
                        } catch (e) {
                            console.error('Error parsing SSE message:', e);
                        }
                    };

                    this.eventSource.onerror = (error) => {
                        this.isConnected = false;
                        this.updateConnectionStatus(false);
                        console.error('SSE connection error:', error);
                        this.addSystemMessage('Lost connection to MCP server. Attempting to reconnect...', 'error');
                    };

                } catch (error) {
                    console.error('Failed to connect to MCP server:', error);
                    this.updateConnectionStatus(false);
                    this.addSystemMessage('Failed to connect to MCP server. Please ensure the server is running.', 'error');
                }
            }

            handleMCPServerMessage(data) {
                console.log('MCP Server message:', data);
                // Handle different types of MCP server messages
                if (data.type === 'connection') {
                    this.addSystemMessage(`MCP Server: ${data.status}`);
                } else if (data.type === 'server_info') {
                    this.addSystemMessage(`Server Info: ${data.data.server_name} v${data.data.version}`);
                } else if (data.type === 'heartbeat') {
                    // Update connection status on heartbeat
                    this.updateConnectionStatus(data.blockchain_connected);
                }
            }

            updateConnectionStatus(connected) {
                this.isConnected = connected;
                const status = this.connectionStatus;
                if (connected) {
                    status.textContent = 'Connected to MCP Server';
                    status.classList.add('connected');
                } else {
                    status.textContent = 'Disconnected from MCP Server';
                    status.classList.remove('connected');
                }
            }

            async sendMessage() {
                const message = this.messageInput.value.trim();
                if (!message || !this.apiKey) {
                    if (!this.apiKey) {
                        this.addSystemMessage('Please enter and save your OpenAI API key first.', 'error');
                    }
                    return;
                }

                this.addUserMessage(message);
                this.messageInput.value = '';
                this.adjustTextareaHeight();
                this.showTypingIndicator();

                // Add to conversation history
                this.conversationHistory.push({
                    role: 'user',
                    content: message
                });

                try {
                    const response = await this.callOpenAI();
                    this.hideTypingIndicator();
                    this.addAssistantMessage(response);
                    this.updateMessageCount();
                } catch (error) {
                    this.hideTypingIndicator();
                    this.addSystemMessage(`Error: ${error.message}`, 'error');
                }
            }

            async callOpenAI() {
                const systemPrompt = `You are an AI assistant for the SEI Solar Charging Station system. You help users with EV charging operations on the SEI blockchain. And you should tell all the values in SEI only not ETH

IMPORTANT: You MUST call tools immediately when users request information, don't just talk about calling them!. You should ask the user SEI address initially , And you should tell all the values in SEI only not ETH

Available MCP server tools:
- health_check: Check server and blockchain health (no parameters needed)
- get_server_info: Get server information (no parameters needed)
- get_all_charging_points: List all charging stations (no parameters needed)
- calculate_charging_price: Calculate charging price - requires: {"station_id": number, "watt": number, "power": number}
- get_user_balance: Get user wallet balance - requires: {"user_address": "0x..."}
- get_gas_estimates: Get gas price estimates (no parameters needed)
- get_user_bookings: Get user's booking history - requires: {"user_address": "0x..."}
- get_booking_details: Get specific booking details - requires: {"booking_id": number}
- get_booking_count: Get total number of bookings (no parameters needed)
- prebook_charging_session: Create a prebooking - requires: {"user_address": "0x...", "station_id": number, "watt": number, "power": number}
- buy_power_from_station: Purchase power - requires: {"user_address": "0x...", "station_id": number, "watt": number, "power": number}
- stop_charging: Smart stop charging session - requires: NO PARAMETERS (completely automatic)
- complete_charging_workflow: Complete workflow - requires: {"user_address": "0x...", "station_id": number, "watt": number, "power": number, "charging_duration_seconds": number}

CRITICAL TOOL CALL RULES:
1. ALWAYS call tools immediately when users ask for data (balance, bookings, etc.)
2. Use the EXACT format: [TOOL_CALL:tool_name{"param":"value"}]
3. For tools with no parameters, use: [TOOL_CALL:tool_name{}]

EXAMPLES:
- User asks "what is my balance" â†’ Immediately respond: [TOOL_CALL:get_user_balance{"user_address":"ask from user"}]
- User asks "stop charging" â†’ Immediately respond: [TOOL_CALL:stop_charging{}]
- User asks "show charging stations" â†’ Immediately respond: [TOOL_CALL:get_all_charging_points{}]

Never say "I will check" or "hold on" - just call the tool directly!

IMPORTANT SEI BLOCKCHAIN CONTEXT:
- This is the SEI blockchain - ALL amounts must be displayed in SEI tokens ONLY
- Never mention ETH, Ethereum, or wei - only SEI and SEI denominations
- Format all amounts as "X.XXXX SEI" for user clarity (e.g., "1.2500 SEI")
- Gas prices should be described as "SEI gas fees"
- All transactions are SEI blockchain transactions
- When showing balances, prices, or refunds - always use SEI units
- Default user address: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...this.conversationHistory.slice(-10) // Keep last 10 messages for context
                ];

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: messages,
                        max_tokens: 1000,
                        temperature: 0.3
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                const content = data.choices[0].message.content;

                // Check if the response contains a tool call
                if (content.includes('[TOOL_CALL:')) {
                    // New simplified format: [TOOL_CALL:tool_name{"param":"value"}] or [TOOL_CALL:tool_name{}]
                    let toolCallMatch = content.match(/\[TOOL_CALL:(\w+)(\{.*?\})\]/);
                    if (toolCallMatch) {
                        const toolName = toolCallMatch[1];
                        const parametersString = toolCallMatch[2];
                        try {
                            const parameters = JSON.parse(parametersString);
                            return await this.executeToolCall(toolName, parameters);
                        } catch (e) {
                            console.error('Error parsing JSON parameters:', e);
                            return `Error: Invalid JSON parameters for tool ${toolName}: ${parametersString}`;
                        }
                    }
                    
                    // Fallback: try old format with spaces
                    toolCallMatch = content.match(/\[TOOL_CALL:\s*(\w+)\s*(\{.*\})\s*\]/);
                    if (toolCallMatch) {
                        const toolName = toolCallMatch[1];
                        const parametersString = toolCallMatch[2];
                        try {
                            const parameters = JSON.parse(parametersString);
                            return await this.executeToolCall(toolName, parameters);
                        } catch (e) {
                            console.error('Error parsing JSON parameters:', e);
                            return `Error: Invalid JSON parameters for tool ${toolName}`;
                        }
                    }

                    // Legacy format support
                    toolCallMatch = content.match(/\[TOOL_CALL:\s*(\w+)\s*\(([^)]*)\)\s*\]/);
                    if (toolCallMatch) {
                        const toolName = toolCallMatch[1];
                        const paramValue = toolCallMatch[2].trim();

                        // Check if the parameter is already a JSON object
                        let params = {};
                        if (paramValue.startsWith('{') && paramValue.endsWith('}')) {
                            try {
                                // It's already a JSON object, parse it directly
                                params = JSON.parse(paramValue);
                            } catch (e) {
                                console.error('Failed to parse JSON parameter:', e);
                                params = {};
                            }
                        } else {
                            // Convert simple parameter to proper format based on tool
                            const cleanValue = paramValue.replace(/"/g, ''); // Remove quotes
                            if (toolName === 'get_user_balance' && cleanValue) {
                                params = { "user_address": cleanValue };
                            } else if (toolName === 'get_booking_details' && cleanValue) {
                                params = { "booking_id": parseInt(cleanValue) };
                            } else if (toolName === 'calculate_charging_price' && cleanValue) {
                                // For calculate_charging_price, we need multiple parameters
                                // This is a fallback - ideally the AI should provide all required params
                                params = {
                                    "station_id": 1,
                                    "watt": 100,
                                    "power": 50
                                };
                            }
                        }

                        return await this.executeToolCall(toolName, params);
                    }
                    
                    // If no pattern matched but contains TOOL_CALL, show debug info
                    console.error('Tool call detected but no pattern matched. Content:', content);
                    return `Error: Detected tool call but couldn't parse format. Content: ${content}`;
                }

                // Add to conversation history
                this.conversationHistory.push({
                    role: 'assistant',
                    content: content
                });

                return content;
            }

            async executeToolCall(toolName, parameters) {
                try {
                    this.addToolCallMessage(`Calling ${toolName}...`);

                    // Ensure parameters is an object, not a string
                    let params = parameters;
                    if (typeof parameters === 'string') {
                        try {
                            params = JSON.parse(parameters);
                        } catch (e) {
                            params = {};
                        }
                    }

                    console.log(`Executing tool ${toolName} with parameters:`, params);

                    const response = await fetch(`http://127.0.0.1:8080/api/tools/${toolName}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(params)
                    });

                    if (!response.ok) {
                        throw new Error(`Tool call failed: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();

                    if (result.success) {
                        const toolResult = `Tool Result (${toolName}):\n${JSON.stringify(result.result, null, 2)}`;
                        this.addToolCallMessage(toolResult);

                        // Add tool result to conversation and get AI interpretation
                        this.conversationHistory.push({
                            role: 'system',
                            content: `Tool result for ${toolName}: ${JSON.stringify(result.result)}`
                        });

                        // Get AI to interpret the tool result
                        const interpretation = await this.getToolInterpretation(toolName, result.result);
                        return interpretation;
                    } else {
                        throw new Error(result.error || 'Tool execution failed');
                    }

                } catch (error) {
                    this.addToolCallMessage(`Tool call failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            async getToolInterpretation(toolName, result) {
                // If the tool failed, provide a helpful error message
                if (result.error) {
                    let errorInterpretation = `Tool Error (${toolName}): ${result.error}`;
                    if (result.note) {
                        errorInterpretation += `\nNote: ${result.note}`;
                    }
                    if (result.example) {
                        errorInterpretation += `\nExample usage: ${JSON.stringify(result.example, null, 2)}`;
                    }

                    this.conversationHistory.push({
                        role: 'assistant',
                        content: errorInterpretation
                    });

                    return errorInterpretation;
                }

                const interpretationPrompt = `Interpret this tool result for the user in a concise, helpful way. Tool: ${toolName}, Result: ${JSON.stringify(result)}`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a helpful interpreter of blockchain tool results. Provide concise, accurate interpretations.' },
                            { role: 'user', content: interpretationPrompt }
                        ],
                        max_tokens: 500,
                        temperature: 0.2
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const interpretation = data.choices[0].message.content;

                    // Add to conversation history
                    this.conversationHistory.push({
                        role: 'assistant',
                        content: interpretation
                    });

                    return interpretation;
                } else {
                    return `Tool executed successfully. Raw result: ${JSON.stringify(result, null, 2)}`;
                }
            }

            addUserMessage(content) {
                this.addMessage('user', content);
            }

            addAssistantMessage(content) {
                this.addMessage('assistant', content);
            }

            addSystemMessage(content, type = 'system') {
                this.addMessage(type, content);
            }

            addToolCallMessage(content, type = 'tool-call') {
                this.addMessage(type, content);
            }

            addMessage(type, content) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;

                const contentDiv = document.createElement('div');
                contentDiv.className = 'content';
                contentDiv.textContent = content;

                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'timestamp';
                timestampDiv.textContent = new Date().toLocaleTimeString();

                messageDiv.appendChild(contentDiv);
                messageDiv.appendChild(timestampDiv);

                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            showTypingIndicator() {
                this.typingIndicator.style.display = 'block';
            }

            hideTypingIndicator() {
                this.typingIndicator.style.display = 'none';
            }

            adjustTextareaHeight() {
                this.messageInput.style.height = 'auto';
                this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
            }

            updateMessageCount() {
                this.messageCount++;
                this.messageCountDisplay.textContent = `${this.messageCount} messages`;
            }

            updateWelcomeTime() {
                const welcomeTime = document.getElementById('welcomeTime');
                if (welcomeTime) {
                    welcomeTime.textContent = new Date().toLocaleString();
                }
            }
        }

        // Initialize the chatbot when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SEIChargingChatbot();
        });
    </script>
</body>
</html>